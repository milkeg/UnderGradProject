<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Lib_Synthese/WSOLA.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>Lib_Synthese/WSOLA.c</h1><a href="_w_s_o_l_a_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00015"></a>00015 <span class="preprocessor">#include&lt;stdio.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include&lt;string.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="_synthese___vocale_8h.html">Synthese_Vocale.h</a>&quot;</span>
<a name="l00021"></a>00021 
<a name="l00033"></a><a class="code" href="group___w_s_o_l_a.html#gae11919ecc5fe905d1731bf585dcd28db">00033</a> <span class="keywordtype">void</span> <a class="code" href="group___w_s_o_l_a.html#gae11919ecc5fe905d1731bf585dcd28db" title="ré-écriture de la structure WAVE du fichier .wav désiré">write_structure</a>(<a class="code" href="struct_w_a_v_e.html" title="Structure d&amp;#39;un fichier WAVE standart Structure codé grace aux structures RIFF...">WAVE</a> *output, <span class="keywordtype">short</span> *tab_sample, <a class="code" href="_synthese___vocale_8h.html#a74cb93d430006e784da73b8ca406ee6e">dword</a> nbr_sample) {
<a name="l00034"></a>00034 
<a name="l00035"></a>00035         <span class="comment">/* calcul des SubchunkSizes:</span>
<a name="l00036"></a>00036 <span class="comment">         *</span>
<a name="l00037"></a>00037 <span class="comment">         * Subchunk1Size vaut toujours 16 pour un fichier PCM.</span>
<a name="l00038"></a>00038 <span class="comment">         *</span>
<a name="l00039"></a>00039 <span class="comment">         * Blockalign: nombre d&#39;octects pour coder un échantillon.</span>
<a name="l00040"></a>00040 <span class="comment">         * Subchunk2Size: nombre d&#39;octects que représente tous les échantillons.</span>
<a name="l00041"></a>00041 <span class="comment">         * on a donc: Subchunk2Size = nb samples * Blockalign</span>
<a name="l00042"></a>00042 <span class="comment">         *</span>
<a name="l00043"></a>00043 <span class="comment">         * d&#39;après la formule: ChunkSize = 4 + (8 + SubChunk1Size) + (8 + SubChunk2Size).</span>
<a name="l00044"></a>00044 <span class="comment">         */</span>
<a name="l00045"></a>00045         <a class="code" href="_synthese___vocale_8h.html#a74cb93d430006e784da73b8ca406ee6e">dword</a> sbck1size = 16;
<a name="l00046"></a>00046         <a class="code" href="_synthese___vocale_8h.html#a74cb93d430006e784da73b8ca406ee6e">dword</a> sbck2size = nbr_sample * output-&gt;<a class="code" href="struct_w_a_v_e.html#a63a69b0767fd94b2295fd25c726a44c8">fmt</a>.<a class="code" href="struct_w_a_v_e_1_1fmt.html#a2dd56ef9b150a9b0e9b53fd98757a75e">Blockalign</a>;
<a name="l00047"></a>00047         <a class="code" href="_synthese___vocale_8h.html#a8829cde3436decd2d2c3d99ed7d649f1">word</a> cksize = 4 + (8 + sbck1size) + (8 + sbck2size);
<a name="l00048"></a>00048 
<a name="l00049"></a>00049         <span class="comment">//affectation de valeurs calculés au champs correspondants de la structure de fichier wav output</span>
<a name="l00050"></a>00050         output-&gt;<a class="code" href="struct_w_a_v_e.html#a54f76f30b774f46c7504e59273f56c6a">RIFF</a>.<a class="code" href="struct_w_a_v_e_1_1_r_i_f_f.html#a18a01a40b7b53561b34a87246ad70b48">ChunkSize</a> = cksize;
<a name="l00051"></a>00051         output-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a17e20c39122954437d62dbf956fabd5b">Subchunk2Size</a> = sbck2size;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053         <span class="comment">/* ré-alocation de la taille du tableau data[] contenant les échantillons de la structure du fichier son</span>
<a name="l00054"></a>00054 <span class="comment">         *</span>
<a name="l00055"></a>00055 <span class="comment">         * Blockalign: nombre d&#39;octects pour coder un sample</span>
<a name="l00056"></a>00056 <span class="comment">         * Subchunk2Size: nombre d&#39;octects que représente tous les échantillons.</span>
<a name="l00057"></a>00057 <span class="comment">         * on a donc le nombre d&#39;échantillons en faisant l&#39;opération Subchunk2Size/Blockalign</span>
<a name="l00058"></a>00058 <span class="comment">         * un échantillon est contenable dans un short donc chaque case doit être de la taille d&#39;un short.</span>
<a name="l00059"></a>00059 <span class="comment">         */</span>
<a name="l00060"></a>00060         output-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a> = realloc(output-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(output-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a17e20c39122954437d62dbf956fabd5b">Subchunk2Size</a> / output-&gt;<a class="code" href="struct_w_a_v_e.html#a63a69b0767fd94b2295fd25c726a44c8">fmt</a>.<a class="code" href="struct_w_a_v_e_1_1fmt.html#a2dd56ef9b150a9b0e9b53fd98757a75e">Blockalign</a>) * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 
<a name="l00063"></a>00063         <span class="comment">//remplissage du tableau d&#39;échantillons data[] de la structure de fichier wav, à partir du tableau d&#39;échantillons modifiés tab_sample[]</span>
<a name="l00064"></a>00064         <span class="keywordtype">int</span> i = 0;
<a name="l00065"></a>00065         <span class="keywordflow">for</span> (i=0; i &lt; nbr_sample ; i++) {
<a name="l00066"></a>00066                 output-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a>[i] = tab_sample[i];
<a name="l00067"></a>00067         }
<a name="l00068"></a>00068 }
<a name="l00069"></a>00069 
<a name="l00082"></a><a class="code" href="group___w_s_o_l_a.html#gaed1a9b24cdf66745d03364c444d9d487">00082</a> <span class="keywordtype">void</span> <a class="code" href="group___w_s_o_l_a.html#gaed1a9b24cdf66745d03364c444d9d487" title="application de l&amp;#39;algorithme WSOLA sur la structure WAVE">wsola</a> (<span class="keywordtype">float</span> speed_factor, <a class="code" href="struct_w_a_v_e.html" title="Structure d&amp;#39;un fichier WAVE standart Structure codé grace aux structures RIFF...">WAVE</a> *son) {
<a name="l00083"></a>00083 
<a name="l00084"></a>00084         <a class="code" href="_synthese___vocale_8h.html#a74cb93d430006e784da73b8ca406ee6e">dword</a> nbr_sample;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         <span class="comment">/* création d&#39;un tableau pour contenir les échantillons</span>
<a name="l00087"></a>00087 <span class="comment">         *</span>
<a name="l00088"></a>00088 <span class="comment">         * dans le cas ou la somme des deltas(k) serait positive, on aurait un peu plus que (nb d&#39;échantillons * coefficient de vitesse) échantillons</span>
<a name="l00089"></a>00089 <span class="comment">         * nb d&#39;échantillons total = Subchunk2Size / Blockalign, seulement ici on ne divise pas Subchunk2Size par Blockalign(qui vaut 2), donc</span>
<a name="l00090"></a>00090 <span class="comment">         * on créé un tableau d&#39;environ deux fois plus de case qu&#39;il ne serait théoriquement nécessaire pour éviter quelconque risque de dépassement de plage mémoire</span>
<a name="l00091"></a>00091 <span class="comment">         */</span>
<a name="l00092"></a>00092         <span class="keywordtype">short</span> *tocopy;
<a name="l00093"></a>00093         tocopy = malloc(((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(( son-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a17e20c39122954437d62dbf956fabd5b">Subchunk2Size</a> * speed_factor)+1)) * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
<a name="l00094"></a>00094         <span class="keywordflow">if</span> (tocopy == NULL) {
<a name="l00095"></a>00095                 printf(<span class="stringliteral">&quot;tocopy malloc problem...\n&quot;</span>);
<a name="l00096"></a>00096                 exit(0);
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="keyword">const</span> <span class="keywordtype">float</span> t_window = 0.020; <span class="comment">//20ms</span>
<a name="l00100"></a>00100         <span class="keyword">const</span> <span class="keywordtype">float</span> N = son-&gt;<a class="code" href="struct_w_a_v_e.html#a63a69b0767fd94b2295fd25c726a44c8">fmt</a>.<a class="code" href="struct_w_a_v_e_1_1fmt.html#ada1c16daae686bb0b9ad51be77eb7af7">SampleRate</a> * t_window; <span class="comment">//nombre d&#39;échantillons dans une fenêtre de taille N (de 20ms)</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102         <span class="comment">//nombre total de fenêtre à parcourir dans le fichier</span>
<a name="l00103"></a>00103         <span class="keyword">const</span> <span class="keywordtype">float</span> data_length = son-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a17e20c39122954437d62dbf956fabd5b">Subchunk2Size</a> / N;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <span class="keyword">const</span> <span class="keywordtype">float</span> t_segment = 0.010; <span class="comment">//10ms</span>
<a name="l00106"></a>00106         <span class="keyword">const</span> <span class="keywordtype">float</span> L = son-&gt;<a class="code" href="struct_w_a_v_e.html#a63a69b0767fd94b2295fd25c726a44c8">fmt</a>.<a class="code" href="struct_w_a_v_e_1_1fmt.html#ada1c16daae686bb0b9ad51be77eb7af7">SampleRate</a> * t_segment; <span class="comment">//nombre d&#39;échantillons dans un segment de taille L (de 10ms)</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         <span class="keyword">const</span> <span class="keywordtype">int</span> step = 64;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         <span class="comment">//création et initialisation des variable de parcours de la boucles</span>
<a name="l00111"></a>00111         <span class="keywordtype">int</span> k = 1;
<a name="l00112"></a>00112         <span class="keywordtype">int</span> n = 0;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         <span class="keywordtype">int</span> delta = 0; <span class="comment">//création et initialisation du delta k</span>
<a name="l00115"></a>00115         <span class="keywordtype">int</span> previous_delta = 0; <span class="comment">//création et initialisation du delta (k-1)</span>
<a name="l00116"></a>00116         <span class="keywordtype">int</span> previous_delta_temp = 0; <span class="comment">//création et initialisation du delta (k-1) temporaire (pour les boucles)</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         <span class="comment">//création et initialisation de &quot;curseurs&quot;</span>
<a name="l00119"></a>00119         <span class="keywordtype">int</span> previous_position = 0;
<a name="l00120"></a>00120         <span class="keywordtype">int</span> current_position = 0;
<a name="l00121"></a>00121         <span class="keywordtype">int</span> desired_position = 0;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         <span class="comment">//création et initialisation du coefficient de similitude (recalculé en permanence dans la boucle)</span>
<a name="l00124"></a>00124         <span class="keywordtype">float</span> coef_similitude = 0;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         <span class="comment">//création et initialisation (à la valeur max d&#39;un float) du coefficient de similitude minimal</span>
<a name="l00127"></a>00127         <span class="keywordtype">float</span> min = 3.40282e+038;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129         <span class="comment">//création d&#39;un tableau de taille L (utilisé uktérieursement pour effectuer les calculs de fades)</span>
<a name="l00130"></a>00130         <span class="keywordtype">short</span> temp[(int)L];
<a name="l00131"></a>00131 
<a name="l00132"></a>00132         <span class="comment">//remplissage du le tableau d&#39;échantillons avec les N premiers échantillons</span>
<a name="l00133"></a>00133         <span class="keywordtype">int</span> i = 0;
<a name="l00134"></a>00134         <span class="keywordflow">for</span> (i=0; i&lt;N; i++) {
<a name="l00135"></a>00135                 tocopy[i] = son-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a>[i]; <span class="comment">//copie l&#39;échantillon i dans le tableau tocopy à la position i</span>
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00139"></a>00139         <span class="comment">/* boucle de recherche du segment le plus adapté</span>
<a name="l00140"></a>00140 <span class="comment">         * utilisant la cross-AMDF-coefficient pour calculer le coefficient de similitude</span>
<a name="l00141"></a>00141 <span class="comment">         * pour chaque k, on cherche le delta qui correspond au segment dans la zone de k le plus similaire au segment qui</span>
<a name="l00142"></a>00142 <span class="comment">         * suit le segment précédent copié [previous_position   previous_position + L]</span>
<a name="l00143"></a>00143 <span class="comment">         */</span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         <span class="comment">//parcours de toutes les fenêtres (totalité du fichier)</span>
<a name="l00146"></a>00146         <span class="keywordflow">while</span> (k &lt; data_length * speed_factor) {
<a name="l00147"></a>00147 
<a name="l00148"></a>00148                 <span class="comment">/* à chaque ré-iteration de la boucle while, il faut ré-initialsier quelques valeurs</span>
<a name="l00149"></a>00149 <span class="comment">                 *</span>
<a name="l00150"></a>00150 <span class="comment">                 * ré-initialisation du minimum à la valeur maximum d&#39;un float</span>
<a name="l00151"></a>00151 <span class="comment">                 * ré-initialisation du coeficient de similitude à 0</span>
<a name="l00152"></a>00152 <span class="comment">                 * affectation du delta(k-1) par le delta(k-1) précédent (càd le delta(k-2))</span>
<a name="l00153"></a>00153 <span class="comment">                 */</span>
<a name="l00154"></a>00154                 min = 3.40282e+038;
<a name="l00155"></a>00155                 coef_similitude = 0;
<a name="l00156"></a>00156                 previous_delta = previous_delta_temp;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158                 <span class="comment">/* pour chaque delta, on va comparer le segment (1&#39;) [previous_position   previous_position+L]</span>
<a name="l00159"></a>00159 <span class="comment">                 * avec le segment (2) [current_position   current_position+L]</span>
<a name="l00160"></a>00160 <span class="comment">                 * cela pour trouver le segment (2) le plus similaire au segment (1)</span>
<a name="l00161"></a>00161 <span class="comment">                 */</span>
<a name="l00162"></a>00162                 <span class="keywordflow">for</span> (delta = -3*step; delta &lt; 3*step; delta++) {
<a name="l00163"></a>00163 
<a name="l00164"></a>00164                         <span class="comment">//échantillon à la position (k-1)L/speed_factor  + delta(k-1) + L</span>
<a name="l00165"></a>00165                         previous_position = (k - 1) * L / speed_factor + previous_delta + L;
<a name="l00166"></a>00166                         <span class="comment">//échantillon à la position (k)L/speed_factor + delta(k)</span>
<a name="l00167"></a>00167                         current_position = k * L / speed_factor + delta;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169                         <span class="comment">/* pour chaque échantillon n (de 0 à L-1) des segments (1&#39;) et (2) on calcule le coefficient de similitude avec la formule:</span>
<a name="l00170"></a>00170 <span class="comment">                         * valeur absolue de la diférence de l&#39;échantillon n du segment (1&#39;) et de l&#39;échantillon n du segment (2)</span>
<a name="l00171"></a>00171 <span class="comment">                         */</span>
<a name="l00172"></a>00172                         <span class="keywordflow">for</span> (n=0; n&lt;L; n++) {
<a name="l00173"></a>00173                                 coef_similitude = abs (son-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a>[n + previous_position] - son-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a>[n + current_position]);
<a name="l00174"></a>00174                         }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176                         <span class="comment">/* si le coefficient actuel est le minimum:</span>
<a name="l00177"></a>00177 <span class="comment">                         * on sauvegarde la position à laquelle le &quot;curseur&quot; est</span>
<a name="l00178"></a>00178 <span class="comment">                         * le minimum</span>
<a name="l00179"></a>00179 <span class="comment">                         */</span>
<a name="l00180"></a>00180                         <span class="keywordflow">if</span> (coef_similitude &lt; min) { <span class="comment">//si le coeficient minimum (cad similitude max)</span>
<a name="l00181"></a>00181                                 desired_position = current_position; <span class="comment">//sauvegarde de la position à  laquelle on doit copier le data (les L samples)</span>
<a name="l00182"></a>00182                                 min = coef_similitude; <span class="comment">//affectation du coef</span>
<a name="l00183"></a>00183                                 previous_delta_temp = delta; <span class="comment">//affectation du delta qui deviendra le delta(k-1) du lors de la prochaine itteraion de k</span>
<a name="l00184"></a>00184                         }
<a name="l00185"></a>00185                 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 
<a name="l00188"></a>00188                 <span class="comment">/* boucle d&#39;ajout des segments trouvés au tableau d&#39;échantillons tocopy[]</span>
<a name="l00189"></a>00189 <span class="comment">                 *</span>
<a name="l00190"></a>00190 <span class="comment">                 * chaque segments B sont ajoutés au tableau tocopy[] en effectuant l&#39;over-lap add sur les L derniers échantillons de tocopy[]</span>
<a name="l00191"></a>00191 <span class="comment">                 * (cd. documentation interne du code.pdf)</span>
<a name="l00192"></a>00192 <span class="comment">                 */</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194                 <span class="comment">/* création et initialisation des indice de parcours de la boucle for à suivre</span>
<a name="l00195"></a>00195 <span class="comment">                 * la position désirée est affecté à la variable j (pour copier les échantillons de la structure WAVE à partir de position désirée)</span>
<a name="l00196"></a>00196 <span class="comment">                 */</span>
<a name="l00197"></a>00197                 <span class="keywordtype">int</span> j = desired_position;
<a name="l00198"></a>00198                 <span class="keywordtype">int</span> x = 0;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200                 <span class="comment">/* on applique un &quot;cos+1&quot; fade-out sur les L derniers échantillons de tocopy[] (segment précedent: [previous_position+L   previous_position+N]</span>
<a name="l00201"></a>00201 <span class="comment">                 * on applique un &quot;cos+1&quot; fade-in sur les L premiers échantillons du segment courant [desired_position   desired_position+L]</span>
<a name="l00202"></a>00202 <span class="comment">                 * on ajoute le deux segements dans tocopy[] (=&gt; over-lap add)</span>
<a name="l00203"></a>00203 <span class="comment">                 */</span>
<a name="l00204"></a>00204                 <span class="keywordflow">for</span> (i= k*L; i&lt; k*L + L; i++) {
<a name="l00205"></a>00205                         tocopy[i] = (short)(tocopy[i] * (( 1 + cos( (x * M_PI) / L ) ) / 2)); <span class="comment">//&quot;cos+1&quot; fade-out</span>
<a name="l00206"></a>00206                         temp[x] = son-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a>[j]; <span class="comment">//copie des échantillons dans le tableau temporaire</span>
<a name="l00207"></a>00207                         temp[x] = (short) (temp[x] * (1 - ( (1+cos( (x * M_PI) / L ) ) / 2 ) ) ); <span class="comment">//&quot;cos+1&quot; fade-in dans le tableau temporaire</span>
<a name="l00208"></a>00208                         tocopy[i] += temp[x]; <span class="comment">//somme des échantillons (add)</span>
<a name="l00209"></a>00209                         j++;
<a name="l00210"></a>00210                         x++;
<a name="l00211"></a>00211                 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213                 <span class="comment">//on copie les L derniers déchantillons dans tocopy[]</span>
<a name="l00214"></a>00214                 <span class="keywordflow">for</span> (i= k*L + L; i&lt; k*L + N; i++) {
<a name="l00215"></a>00215                         tocopy[i] = son-&gt;<a class="code" href="struct_w_a_v_e.html#a31d2ace2648f8bec29ba2a06cab24fa7">data</a>.<a class="code" href="struct_w_a_v_e_1_1data.html#a5b5b032f747e9383fc0d98f7054e258f">data</a>[j];
<a name="l00216"></a>00216                         j++;
<a name="l00217"></a>00217                 }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219                 k++;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         <span class="comment">/* sauvegarde de la position du dernier échantillon copié dans le tableau tocopy[]</span>
<a name="l00224"></a>00224 <span class="comment">         * correspond au nombre d&#39;échantillons à écrire dans la structure WAVE à modifier</span>
<a name="l00225"></a>00225 <span class="comment">         */</span>
<a name="l00226"></a>00226         nbr_sample = i;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         <span class="comment">/* le tableau d&#39;échantillons tocopy[] maintenant rempli jusque nbr_sample, il faut reconstruire la structure WAVE modifiée.</span>
<a name="l00229"></a>00229 <span class="comment">         * on appel donc la fonction write_structure pour modifier la structure WAVE passé par adresse.</span>
<a name="l00230"></a>00230 <span class="comment">         */</span>
<a name="l00231"></a>00231         <a class="code" href="group___w_s_o_l_a.html#gae11919ecc5fe905d1731bf585dcd28db" title="ré-écriture de la structure WAVE du fichier .wav désiré">write_structure</a>(son, tocopy, nbr_sample);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         <span class="comment">//libération de l&#39;espace mémoire aloué au tableau tocopy[]</span>
<a name="l00234"></a>00234         free(tocopy);
<a name="l00235"></a>00235 }
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri May 7 15:55:12 2010 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
